import vmecpp
import numpy as np
from collections import OrderedDict
import matplotlib.pyplot as plt
from pathlib import Path
from scipy.interpolate import interp1d
from mitim_tools.misc_tools import GRAPHICStools, IOtools
from mitim_tools.plasmastate_tools import MITIMstate
from mitim_tools.misc_tools.LOGtools import printMsg as print
from IPython import embed

class vmec_state(MITIMstate.mitim_state):
    '''
    Class to read and manipulate VMEC files
    '''

    # ************************************************************************************************************************************************
    # Reading and interpreting
    # ************************************************************************************************************************************************

    def __init__(
        self,
        file_vmec,
        file_profs,
        derive_quantities=True,
        mi_ref=None
    ):

        # Initialize the base class and tell it the type of file
        super().__init__(type_file='vmec')

        
        self.header = ['# VMEC state file generated by MITIMtools\n']
        self.titles_singleNum = ["nexp", "nion", "shot", "name", "type", "time"]
        self.titles_singleArr = ["masse","mass","ze","z","torfluxa(Wb/radian)","rcentr(m)","bcentr(T)"] #,"current(MA)"]
        self.titles_single = self.titles_singleNum + self.titles_singleArr
        
        # Read the input file and store the raw data
        self.files = [file_vmec, file_profs]
        if self.files is not None:
            self._read_vmec()
            
            # Derive (Depending on resolution, derived can be expensive, so I may not do it every time)
            self.derive_quantities(mi_ref=mi_ref, derive_quantities=derive_quantities)

    @IOtools.hook_method(after=MITIMstate.ensure_variables_existence)
    def _read_vmec(self):

        # Read VMEC file
        print("\t- Reading VMEC file")
        self.wout = vmecpp.VmecWOut.from_wout_file(Path(self.files[0]))

        # Initialize profiles dictionary
        self.profiles = OrderedDict()
        
        self.profiles['nion'] = np.array([1])
        self.profiles['name'] = np.array(['D'])
        self.profiles['type'] = np.array(['[therm]'])
        self.profiles['mass'] = np.array([2.0])
        self.profiles['z'] = np.array([1.0])

        self.profiles['rcentr(m)'] = np.array([self.wout.Rmajor_p])
        self.profiles['bcentr(T)'] = np.array([self.wout.rbtor/self.wout.Rmajor_p])
        self.profiles["current(MA)"] = np.array([0.0])

        self.profiles["torfluxa(Wb/radian)"] = np.array([self.wout.phipf[-1]])

        # Produce variables
        self.profiles["rho(-)"] = (self.wout.phi/self.wout.phi[-1])**0.5 #np.linspace(0, 1, self.wout.ns)**0.5
        self.profiles["ptot(Pa)"] = self.wout.presf

        #self.profiles["q(-)"] = self.wout.q_factor
        #self.profiles["polflux(Wb/radian)"] = self.wout.chi

        # Read Profiles
        data = self._read_profiles(x_coord=self.profiles["rho(-)"])

        self.profiles['te(keV)'] = data['Te']
        self.profiles['ne(10^19/m^3)'] = data['ne']
        self.profiles['ti(keV)'] = np.atleast_2d(data['Ti']).T
        self.profiles['ni(10^19/m^3)'] = np.atleast_2d(data['ni']).T

        self.profiles['qbeami(MW/m^3)'] = data['Qi'] * 1e-6     # Convert from W/m^3 to MW/m^3
        self.profiles['qrfe(MW/m^3)'] = data['Qe'] * 1e-6       # Convert from W/m^3 to MW/m^3
        self.profiles['qpar_beam(1/m^3/s)'] = data['S']

    # ************************************************************************************************************************************************
    # Derivation (different from MITIMstate)
    # ************************************************************************************************************************************************
   
    def derive_quantities(self, **kwargs):
 
        if "derived" not in self.__dict__:
            self.derived = {}

        # Define the minor radius used in all calculations (could be the half-width of the midplance intersect, or an effective minor radius)
        self.derived["r"] = self.profiles["rho(-)"] # Assume that r = rho so r/a = rho too

        super().derive_quantities_base(**kwargs)

    def derive_geometry(self, **kwargs):
        
        r = self.derived["r"]

        half_grid_r = r - (r[1] - r[0]) / 2
        d_volume_d_r = (
            (2 * np.pi) ** 2
            * np.array(self.wout.vp)
            * 2
            * np.sqrt(half_grid_r)
        )        

        self.derived["B_ref"] = np.ones(r.shape) * self.profiles["torfluxa(Wb/radian)"][-1] / (np.pi * self.wout.Aminor_p**2)

        self.derived["volp_geo"] = d_volume_d_r
        self.derived["volp_geo"][0] = 1E-9
        
        self.derived["kappa_a"] = 0.0
        self.derived["kappa95"] = 0.0
        self.derived["delta95"] = 0.0
        self.derived["kappa995"] = 0.0
        self.derived["delta995"] = 0.0
        self.derived["R_LF"] = np.zeros(r.shape)

        self.derived["bp2_exp"] = np.zeros(r.shape)
        self.derived["bt2_exp"] = np.zeros(r.shape)
        self.derived["bp2_geo"] = np.zeros(r.shape)
        self.derived["bt2_geo"] = np.zeros(r.shape)

    def plot_geometry(self, axs, color="b", legYN=True, extralab="", lw=1, fs=6):
        
        [ax00c,ax10c,ax20c,ax01c,ax11c,ax21c,ax02c,ax12c,ax22c,axs_3d,axs_2d] = axs
        
        rho = self.profiles["rho(-)"]
        
        ax = ax00c

        var = self.derived['r']
        ax.plot(rho, var, "-", lw=lw, c=color)

        ax.set_xlim([0, 1])
        ax.set_xlabel("$\\rho$")
        ax.set_ylim(bottom=0)
        ax.set_ylabel("Effective radius ($r$)")

        GRAPHICStools.addDenseAxis(ax)
        GRAPHICStools.autoscale_y(ax, bottomy=0)
        
        ax = ax01c
        ax.plot(rho, self.derived['volp_geo'], color=color, lw=lw, label = extralab)
        ax.set_xlabel('$\\rho$'); ax.set_xlim(0, 1)
        ax.set_ylabel(f"$dV/d\\rho$ ($m^3$)")
        GRAPHICStools.addDenseAxis(ax)
        
        if legYN:
            ax.legend(loc="best", fontsize=fs)
        
        # ----
        phis_plot = [0.0, np.pi/2, np.pi, 3*np.pi/2]
        
        self.plot_plasma_boundary(ax=axs_3d, color=color, phi_cuts=phis_plot)
        self.plot_state_flux_surfaces(ax=axs_2d, c=color, phis_plot=phis_plot)

    def plot_state_flux_surfaces(self, ax=None, c='b', phis_plot=[0.0]):
        
        rhos_plot = np.linspace(0.0, 1.0, 10)
        

        ls = GRAPHICStools.listLS()
        
        for phi_cut, lsi in zip(phis_plot, ls):
        
            for i in range(len(rhos_plot)):
                self.plot_flux_surface(ax = ax, phi_cut=phi_cut, rho=rhos_plot[i], c=c, lw = 0.5, ls = lsi)
            self.plot_flux_surface(ax = ax, phi_cut=phi_cut, rho=1.0, c=c, lw = 4, ls = lsi, label = f"{phi_cut*180/np.pi:.1f}°")

        ax.set_aspect('equal')
        ax.set_xlabel('R [m]')
        ax.set_ylabel('Z [m]')
        GRAPHICStools.addDenseAxis(ax)
        ax.legend(loc='best', fontsize=6)
        #GRAPHICStools.addLegendApart(ax, ratio=0.9, size=6)

        ax.set_title(f'Poloidal cross-sections')

    def _read_profiles(self, x_coord=None, debug = False):
        
        filename = self.files[1]
        
        if x_coord is None:
            # Create uniform coordinate array from 0 to 1
            x_coord = np.linspace(0, 1, 200)
        
        # Raw data storage
        raw_data = {
            'Te_data': {'x': [], 'y': []},
            'ne_data': {'x': [], 'y': []},
            'Ti_data': {'x': [], 'y': []},
            'ni_data': {'x': [], 'y': []},
            'S_data': {'x': [], 'y': []},
            'Qe_data': {'x': [], 'y': []},
            'Qi_data': {'x': [], 'y': []}
        }
        current_section = None
        
        with open(filename, 'r') as f:
            lines = f.readlines()
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
                
            # Check for section headers
            if line.startswith('#'):
                if 'Te' in line and 'ne' in line:
                    current_section = 'Te_ne'
                elif 'Ti' in line and 'ni' in line:
                    current_section = 'Ti_ni'
                elif 'Particle source' in line:
                    current_section = 'S'
                elif 'Q W/m3' in line:
                    current_section = 'Qe'
                elif 'NBI W/m3' in line:
                    current_section = 'Qi'
                continue
            
            # Parse data lines
            parts = line.split()
            if len(parts) < 2:
                continue
                
            x = float(parts[0])  # x/a or r/a coordinate (first column)
            
            if current_section == 'Te_ne' and len(parts) == 4:
                # x/a, x/rho, Te, ne - use x/a coordinate
                raw_data['Te_data']['x'].append(x)
                raw_data['Te_data']['y'].append(float(parts[2]))
                raw_data['ne_data']['x'].append(x)
                raw_data['ne_data']['y'].append(float(parts[3]))
                
            elif current_section == 'Ti_ni' and len(parts) == 4:
                # x/a, x/rho, Ti, ni - use x/a coordinate
                raw_data['Ti_data']['x'].append(x)
                raw_data['Ti_data']['y'].append(float(parts[2]))
                raw_data['ni_data']['x'].append(x)
                raw_data['ni_data']['y'].append(float(parts[3]))
                
            elif current_section == 'S' and len(parts) == 2:
                raw_data['S_data']['x'].append(x)
                raw_data['S_data']['y'].append(float(parts[1]))
                
            elif current_section == 'Qe' and len(parts) == 2:
                raw_data['Qe_data']['x'].append(x)
                raw_data['Qe_data']['y'].append(float(parts[1]))
                
            elif current_section == 'Qi' and len(parts) == 2:
                raw_data['Qi_data']['x'].append(x)
                raw_data['Qi_data']['y'].append(float(parts[1]))
        
        # Convert to numpy arrays
        for profile_data in raw_data.values():
            profile_data['x'] = np.array(profile_data['x'])
            profile_data['y'] = np.array(profile_data['y'])
        
        # Interpolate each profile to uniform grid
        uniform_data = {'x_coord': x_coord}
        
        profile_map = {
            'Te': 'Te_data', 'ne': 'ne_data', 'Ti': 'Ti_data', 
            'ni': 'ni_data', 'S': 'S_data', 'Qe': 'Qe_data', 'Qi': 'Qi_data'
        }
        
        for profile_name, data_key in profile_map.items():
            x_data = raw_data[data_key]['x']
            y_data = raw_data[data_key]['y']
            
            if len(x_data) > 0:
                # Interpolate using actual coordinates from the data
                f = interp1d(x_data, y_data, kind='linear', 
                            bounds_error=False, fill_value=(y_data[0], y_data[-1]))
                uniform_data[profile_name] = f(x_coord)
            else:
                uniform_data[profile_name] = None
        
        # Also store original data for plotting
        uniform_data['raw_data'] = raw_data
        
        if debug:
            plot_profiles(uniform_data)
            embed()
        
        return uniform_data

    def plot_plasma_boundary(self, ax=None, color="b", phi_cuts=[]):

        # The output object contains the Fourier coefficients of the geometry in R and Z
        # as a function of the poloidal (theta) and toroidal (phi) angle-like coordinates
        # for a number of discrete radial locations.

        # number of flux surfaces, i.e., final radial resolution
        ns = self.wout.ns

        # poloidal mode numbers: m
        xm = self.wout.xm

        # toroidal mode numbers: n * nfp
        xn = self.wout.xn

        # stellarator-symmetric Fourier coefficients of flux surface geometry R ~ cos(m * theta - n * nfp * phi)
        rmnc = self.wout.rmnc

        # stellarator-symmetric Fourier coefficients of flux surface geometry Z ~ sin(m * theta - n * nfp * phi)
        zmns = self.wout.zmns

        # plot the outermost (last) flux surface, which is the plasma boundary
        j = ns - 1

        # resolution over the flux surface
        num_theta = 101
        num_phi = 181
        
        min_phi = 0.0
        max_phi = 2.0 * np.pi

        # grid in theta and phi along the flux surface
        grid_theta = np.linspace(0.0, 2.0 * np.pi, num_theta, endpoint=True)
        grid_phi = np.linspace(min_phi, max_phi, num_phi, endpoint=True)

        # compute Cartesian coordinates of flux surface geometry
        x = np.zeros([num_theta, num_phi])
        y = np.zeros([num_theta, num_phi])
        z = np.zeros([num_theta, num_phi])
        for idx_theta, theta in enumerate(grid_theta):
            for idx_phi, phi in enumerate(grid_phi):
                kernel = xm * theta - xn * phi
                r = np.dot(rmnc[:, j], np.cos(kernel))
                x[idx_theta, idx_phi] = r * np.cos(phi)
                y[idx_theta, idx_phi] = r * np.sin(phi)
                z[idx_theta, idx_phi] = np.dot(zmns[:, j], np.sin(kernel))

        # actually make the 3D plot
        if ax is None:
            fig = plt.figure()
            ax = fig.add_subplot(projection="3d")

        # Plot the surface
        ax.plot_surface(x, y, z, alpha=0.3 if len(phi_cuts)>0 else 0.7, color=color)

        # Add cutting planes at specific toroidal angles
        for phi_cut in phi_cuts:
            self._add_cutting_plane(ax, phi_cut, j, xm, xn, rmnc, zmns, color)

        # Set an equal aspect ratio
        ax.set_aspect("equal")
        
        ax.set_title(f'3D plasma boundary')

    def plot_flux_surface(self, ax=None, phi_cut=0.0, rho=1.0, c='b', lw=1, ls='-', label = ''):
        """
        Plot poloidal cross-section of the torus at a specified toroidal angle.
        
        Parameters:
        -----------
        ax : matplotlib axes object, optional
            Axes to plot on. If None, creates new figure and axes.
        phi_cut : float, optional
            Toroidal angle for the cross-section in radians. Default is 0.0.
        rho : float, optional
            Normalized flux surface coordinate (0 to 1). Default is 1.0 (boundary).
        """
        
        ns = self.wout.ns
        xm = self.wout.xm
        xn = self.wout.xn
        rmnc = self.wout.rmnc
        zmns = self.wout.zmns

        # Find closest flux surface index for given rho
        rho_grid = self.profiles["rho(-)"]
        j = np.argmin(np.abs(rho_grid - rho))

        num_theta = 201
        grid_theta = np.linspace(0.0, 2.0 * np.pi, num_theta, endpoint=True)

        R = np.zeros(num_theta)
        Z = np.zeros(num_theta)
        
        for idx_theta, theta in enumerate(grid_theta):
            kernel = xm * theta - xn * phi_cut
            R[idx_theta] = np.dot(rmnc[:, j], np.cos(kernel))
            Z[idx_theta] = np.dot(zmns[:, j], np.sin(kernel))

        if ax is None:
            plt.ion()
            fig, ax = plt.subplots()

        ax.plot(R, Z, ls=ls, color = c, linewidth=lw, label=label)

    def _add_cutting_plane(self, ax, phi_cut, j, xm, xn, rmnc, zmns, plane_color):
        """
        Add a cutting plane at a specific toroidal angle to the 3D plot.
        
        Parameters:
        -----------
        ax : matplotlib 3D axes
            The 3D axes to plot on
        phi_cut : float
            Toroidal angle for the cutting plane in radians
        j : int
            Flux surface index (typically ns-1 for boundary)
        xm, xn : array
            Poloidal and toroidal mode numbers
        rmnc, zmns : array
            Fourier coefficients for R and Z
        plane_color : str
            Color for the cutting plane
        """
        num_theta = 101
        grid_theta = np.linspace(0.0, 2.0 * np.pi, num_theta, endpoint=True)

        R = np.zeros(num_theta)
        Z = np.zeros(num_theta)
        X = np.zeros(num_theta)
        Y = np.zeros(num_theta)
        
        for idx_theta, theta in enumerate(grid_theta):
            kernel = xm * theta - xn * phi_cut
            r = np.dot(rmnc[:, j], np.cos(kernel))
            R[idx_theta] = r
            Z[idx_theta] = np.dot(zmns[:, j], np.sin(kernel))
            X[idx_theta] = r * np.cos(phi_cut)
            Y[idx_theta] = r * np.sin(phi_cut)

        # Plot the cutting plane as a line in 3D
        ax.plot(X, Y, Z, color=plane_color, linewidth=2, 
                label=f'φ = {phi_cut*180/np.pi:.0f}°')

def plot_profiles(data):
    """
    Create plots of the plasma profiles
    """
    fig, axes = plt.subplots(2, 3, figsize=(15, 10))
    
    raw_data = data['raw_data']
    
    # Temperature profiles
    if len(raw_data['Te_data']['x']) > 0:
        axes[0,0].plot(raw_data['Te_data']['x'], raw_data['Te_data']['y'], 'ro-', label='Te (original)', markersize=3)
        if data['Te'] is not None:
            axes[0,0].plot(data['x_coord'], data['Te'], 'r-', label='Te (interpolated)', linewidth=2)
    
    if len(raw_data['Ti_data']['x']) > 0:
        axes[0,0].plot(raw_data['Ti_data']['x'], raw_data['Ti_data']['y'], 'bo-', label='Ti (original)', markersize=3)
        if data['Ti'] is not None:
            axes[0,0].plot(data['x_coord'], data['Ti'], 'b-', label='Ti (interpolated)', linewidth=2)
    
    axes[0,0].set_xlabel('x/a')
    axes[0,0].set_ylabel('Temperature [keV]')
    axes[0,0].legend()
    axes[0,0].grid(True)
    axes[0,0].set_title('Temperature Profiles')
    
    # Density profiles
    if len(raw_data['ne_data']['x']) > 0:
        axes[0,1].plot(raw_data['ne_data']['x'], raw_data['ne_data']['y'], 'ro-', label='ne (original)', markersize=3)
        if data['ne'] is not None:
            axes[0,1].plot(data['x_coord'], data['ne'], 'r-', label='ne (interpolated)', linewidth=2)
    
    if len(raw_data['ni_data']['x']) > 0:
        axes[0,1].plot(raw_data['ni_data']['x'], raw_data['ni_data']['y'], 'bo-', label='ni (original)', markersize=3)
        if data['ni'] is not None:
            axes[0,1].plot(data['x_coord'], data['ni'], 'b-', label='ni (interpolated)', linewidth=2)
    
    axes[0,1].set_xlabel('x/a')
    axes[0,1].set_ylabel('Density [10¹⁹ m⁻³]')
    axes[0,1].legend()
    axes[0,1].grid(True)
    axes[0,1].set_title('Density Profiles')
    
    # Particle source
    if len(raw_data['S_data']['x']) > 0:
        axes[0,2].plot(raw_data['S_data']['x'], raw_data['S_data']['y'], 'go-', label='S (original)', markersize=3)
        if data['S'] is not None:
            axes[0,2].plot(data['x_coord'], data['S'], 'g-', label='S (interpolated)', linewidth=2)
    axes[0,2].set_xlabel('x/a')
    axes[0,2].set_ylabel('Particle Source [m⁻³s⁻¹]')
    axes[0,2].legend()
    axes[0,2].grid(True)
    axes[0,2].set_title('Particle Source')
    
    # Electron heating
    if len(raw_data['Qe_data']['x']) > 0:
        axes[1,0].plot(raw_data['Qe_data']['x'], raw_data['Qe_data']['y'], 'ro-', label='Qe (original)', markersize=3)
        if data['Qe'] is not None:
            axes[1,0].plot(data['x_coord'], data['Qe'], 'r-', label='Qe (interpolated)', linewidth=2)
    axes[1,0].set_xlabel('x/a')
    axes[1,0].set_ylabel('Qe [W/m³]')
    axes[1,0].legend()
    axes[1,0].grid(True)
    axes[1,0].set_title('Electron Heating')
    
    # Ion heating
    if len(raw_data['Qi_data']['x']) > 0:
        axes[1,1].plot(raw_data['Qi_data']['x'], raw_data['Qi_data']['y'], 'bo-', label='Qi (original)', markersize=3)
        if data['Qi'] is not None:
            axes[1,1].plot(data['x_coord'], data['Qi'], 'b-', label='Qi (interpolated)', linewidth=2)
    axes[1,1].set_xlabel('x/a')
    axes[1,1].set_ylabel('Qi [W/m³]')
    axes[1,1].legend()
    axes[1,1].grid(True)
    axes[1,1].set_title('Ion Heating (NBI)')
    
    # Remove empty subplot
    axes[1,2].remove()
    
    plt.tight_layout()
    plt.show()